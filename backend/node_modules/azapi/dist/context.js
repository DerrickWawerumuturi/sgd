"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useContext = useContext;
exports.applyInterface = applyInterface;
exports.UNSAFE_setContext = UNSAFE_setContext;
exports.UNSAFE_createContext = UNSAFE_createContext;

if (!Promise.__applyHooks) {
  Promise.__applyHooks = true;
  const {
    then: $then,
    catch: $catch,
    finally: $finally
  } = Promise.prototype;
  Object.assign(Promise.prototype, {
    then(onResolve, onReject) {
      return $then.call(this, wrap(onResolve), wrap(onReject));
    },

    catch(onCatch) {
      return $catch.call(this, wrap(onCatch));
    },

    finally(onFinally) {
      return $finally.call(this, wrap(onFinally));
    }

  });
}

function wrap(f) {
  if (!f) {
    return f;
  }

  const context = useContext();
  return function () {
    let prevContext = useContext();

    try {
      UNSAFE_setContext(context);
      return f.apply(this, arguments);
    } finally {
      UNSAFE_setContext(prevContext);
    }
  };
}

let currentContext;

function useContext() {
  return currentContext;
}

function applyInterface(context) {
  const on = {};
  Object.assign(context, {
    on(name, handler) {
      let handlers = on[name];

      if (!handlers) {
        on[name] = handlers = new Set();
      }

      handlers.add(handler);
      return () => handlers.delete(handler);
    },

    emit(name, args = context) {
      const handlers = on[name];

      if (!handlers) {
        return;
      }

      return Array.from(handlers).reduce((prev, handler) => {
        if (prev && typeof prev.then === 'function') {
          return prev.finally(() => {
            return handler(args);
          });
        } else {
          return handler(args);
        }
      }, null);
    }

  });
  return context;
}

function UNSAFE_setContext(newContext) {
  currentContext = newContext;
}

function UNSAFE_createContext(req, res, props) {
  return applyInterface({
    req,
    res,
    ...props
  });
}
//# sourceMappingURL=context.js.map